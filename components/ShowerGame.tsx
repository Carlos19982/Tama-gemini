import React, { useState, useEffect, useRef } from 'react';
import { PetRender } from './PetRender';
import { PetAppearance } from '../types';
import { MAX_GROWTH_AGE } from '../constants';

interface ShowerGameProps {
  appearance: PetAppearance;
  age: number;
  onComplete: () => void;
}

export const ShowerGame: React.FC<ShowerGameProps> = ({ appearance, age, onComplete }) => {
  const [dirt, setDirt] = useState<{id: number, x: number, y: number}[]>([]);
  const [spongePos, setSpongePos] = useState({ x: 50, y: 50 }); // Percentage
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Initialize dirt
  useEffect(() => {
    // Calculate current pet scale to place dirt correctly
    const growthStage = Math.min(age, MAX_GROWTH_AGE) / MAX_GROWTH_AGE;
    const scale = 0.6 + (0.4 * growthStage);
    const range = 30 * scale; // Adjust dirt spread based on size

    const newDirt = [];
    for(let i = 0; i < 15; i++) {
      newDirt.push({
        id: i,
        // Keep dirt on the pet's body
        x: 50 + (Math.random() * 2 - 1) * range, 
        y: 55 + (Math.random() * 2 - 1) * range 
      });
    }
    setDirt(newDirt);
  }, [age]);

  const handlePointerMove = (e: React.PointerEvent | React.MouseEvent | React.TouchEvent) => {
    if (!containerRef.current) return;
    
    const rect = containerRef.current.getBoundingClientRect();
    let clientX, clientY;

    if ('touches' in e) {
       clientX = e.touches[0].clientX;
       clientY = e.touches[0].clientY;
    } else {
       clientX = (e as React.MouseEvent).clientX;
       clientY = (e as React.MouseEvent).clientY;
    }

    // Calculate percentage position within the container
    const x = ((clientX - rect.left) / rect.width) * 100;
    const y = ((clientY - rect.top) / rect.height) * 100;

    setSpongePos({ x, y });

    // Check collision with dirt
    setDirt(prev => {
      // "Hitbox" for sponge is roughly 10% wide
      const remaining = prev.filter(d => {
        const dist = Math.sqrt(Math.pow(d.x - x, 2) + Math.pow(d.y - y, 2));
        return dist > 10; // Keep dirt if distance > 10
      });

      if (remaining.length === 0 && prev.length > 0) {
        setTimeout(onComplete, 1200);
      }
      return remaining;
    });
  };

  const isClean = dirt.length === 0;

  return (
    <div 
      className="relative w-full h-full bg-cyan-100 flex flex-col items-center overflow-hidden touch-none select-none"
      ref={containerRef}
      onMouseMove={handlePointerMove}
      onTouchMove={handlePointerMove}
    >
      {/* Tiled Background Pattern */}
      <div 
        className="absolute inset-0 opacity-20 pointer-events-none"
        style={{
            backgroundImage: `linear-gradient(#fff 2px, transparent 2px), linear-gradient(90deg, #fff 2px, transparent 2px)`,
            backgroundSize: '40px 40px'
        }}
      ></div>

      <div className="z-10 mt-4 bg-white/80 px-4 py-2 rounded-full shadow-sm border border-cyan-200">
        <h2 className="text-lg font-bold text-cyan-800 animate-pulse">
            {isClean ? 'ALL CLEAN!' : 'SCRUB THE DIRT!'}
        </h2>
      </div>
      
      {/* Main Game Area */}
      <div className="relative w-64 h-64 mt-10 pointer-events-none">
        {/* Shower Head Visual (Decoration) */}
        <div className="absolute -top-24 right-0 z-0 opacity-50">
           <div className="w-32 h-32 border-t-8 border-r-8 border-gray-400 rounded-tr-[4rem]"></div>
           <div className="absolute bottom-0 left-0 w-16 h-4 bg-gray-500 rounded-full rotate-12"></div>
           {/* Water */}
           <div className="absolute top-[130px] left-2 flex gap-1">
             <div className="w-1 h-32 bg-cyan-300 animate-[bounce_0.5s_infinite]"></div>
             <div className="w-1 h-40 bg-cyan-400 animate-[bounce_0.6s_infinite]"></div>
             <div className="w-1 h-28 bg-cyan-300 animate-[bounce_0.7s_infinite]"></div>
           </div>
        </div>

        {/* Pet */}
        <PetRender 
          appearance={appearance} 
          age={age}
          mood={isClean ? 'happy' : 'neutral'} 
          className="w-full h-full z-10"
        />

        {/* Dirt Spots (Interactive targets) */}
        {dirt.map((d) => (
          <div
            key={d.id}
            className="absolute w-10 h-10 rounded-full flex items-center justify-center transition-transform z-20"
            style={{ top: `${d.y}%`, left: `${d.x}%`, transform: 'translate(-50%, -50%)' }}
          >
             <span className="text-3xl filter drop-shadow-md grayscale opacity-80">ðŸ’©</span>
          </div>
        ))}
        
        {/* Bubbles generated by cleaning (visual flair when almost clean) */}
        {dirt.length < 5 && !isClean && (
             <div className="absolute inset-0 pointer-events-none">
                <div className="absolute top-10 left-10 text-xl animate-bounce opacity-50">ðŸ«§</div>
                <div className="absolute bottom-10 right-10 text-xl animate-bounce delay-100 opacity-50">ðŸ«§</div>
             </div>
        )}

        {isClean && (
             <div className="absolute inset-0 pointer-events-none flex items-center justify-center">
                 <div className="text-6xl animate-ping">âœ¨</div>
             </div>
        )}
      </div>

      {/* Sponge Cursor Follower */}
      {!isClean && (
          <div 
            className="absolute pointer-events-none z-50 transition-transform duration-75 ease-out"
            style={{ 
                top: `${spongePos.y}%`, 
                left: `${spongePos.x}%`, 
                transform: 'translate(-50%, -50%)'
            }}
          >
            <div className="text-5xl filter drop-shadow-xl animate-wiggle">
                ðŸ§½
            </div>
            {/* Suds */}
            <div className="absolute top-0 left-0 w-full h-full animate-ping opacity-30 bg-white rounded-full scale-150"></div>
          </div>
      )}

      {/* Helper Text */}
      <div className="absolute bottom-6 text-cyan-700 text-sm font-bold opacity-60">
         DRAG TO SCRUB
      </div>
    </div>
  );
};